diff --git a/core/Cargo.lock b/core/Cargo.lock
index ab257c9..9102b8a 100644
--- a/core/Cargo.lock
+++ b/core/Cargo.lock
@@ -9,6 +9,7 @@ dependencies = [
  "derive-new",
  "derive_builder",
  "getset",
+ "petgraph",
  "serde_json",
  "thiserror",
  "uuid",
@@ -103,12 +104,30 @@ dependencies = [
  "syn",
 ]
 
+[[package]]
+name = "equivalent"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"
+
+[[package]]
+name = "fixedbitset"
+version = "0.5.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d674e81391d1e1ab681a28d99df07927c6d4aa5b027d7da16ba32d1d21ecd99"
+
 [[package]]
 name = "fnv"
 version = "1.0.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"
 
+[[package]]
+name = "foldhash"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9c4f5dac5e15c24eb999c26181a6ca40b39fe946cbe4c263c7209467bc83af2"
+
 [[package]]
 name = "getrandom"
 version = "0.3.4"
@@ -133,12 +152,37 @@ dependencies = [
  "syn",
 ]
 
+[[package]]
+name = "hashbrown"
+version = "0.15.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"
+dependencies = [
+ "foldhash",
+]
+
+[[package]]
+name = "hashbrown"
+version = "0.16.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "841d1cc9bed7f9236f321df977030373f4a4163ae1a7dbfe1a51a2c1a51d9100"
+
 [[package]]
 name = "ident_case"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
 
+[[package]]
+name = "indexmap"
+version = "2.13.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7714e70437a7dc3ac8eb7e6f8df75fd8eb422675fc7678aff7364301092b1017"
+dependencies = [
+ "equivalent",
+ "hashbrown 0.16.1",
+]
+
 [[package]]
 name = "itoa"
 version = "1.0.17"
@@ -173,6 +217,18 @@ version = "1.21.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"
 
+[[package]]
+name = "petgraph"
+version = "0.8.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8701b58ea97060d5e5b155d383a69952a60943f0e6dfe30b04c287beb0b27455"
+dependencies = [
+ "fixedbitset",
+ "hashbrown 0.15.5",
+ "indexmap",
+ "serde",
+]
+
 [[package]]
 name = "proc-macro-error-attr2"
 version = "2.0.0"
diff --git a/core/Cargo.toml b/core/Cargo.toml
index 6d4053f..d66985d 100644
--- a/core/Cargo.toml
+++ b/core/Cargo.toml
@@ -7,6 +7,7 @@ edition = "2024"
 derive-new = "0.7.0"
 derive_builder = "0.20.2"
 getset = "0.1.6"
+petgraph = "0.8.3"
 serde_json = "1.0.149"
 thiserror = "2.0.18"
 uuid = { version = "1.19.0", features = ["v4", "serde"] }
diff --git a/core/src/error.rs b/core/src/error.rs
index b49f487..4490699 100644
--- a/core/src/error.rs
+++ b/core/src/error.rs
@@ -1,12 +1,19 @@
 use thiserror::Error;
 
-use crate::{task::TaskError, workflow::WorkflowError};
+use crate::{
+    task::TaskError,
+    workflow::{WorkflowError, execution::ExecutionError},
+};
 
+/// Core errors that can occur in the Autoflow system
 #[derive(Debug, Error)]
 pub enum CoreError {
     #[error("workflow error: {0}")]
     Workflow(#[from] WorkflowError),
 
+    #[error("execution error: {0}")]
+    Execution(#[from] ExecutionError),
+
     #[error("task error: {0}")]
     Task(#[from] TaskError),
 }
diff --git a/core/src/lib.rs b/core/src/lib.rs
index 8d259fa..e613c6a 100644
--- a/core/src/lib.rs
+++ b/core/src/lib.rs
@@ -11,26 +11,64 @@ pub use value::Value;
 
 #[cfg(test)]
 pub mod test {
+    use std::collections::HashMap;
+
     use crate::{
+        Value,
         plugin::{Plugin, Registry},
-        task::{DataType, InputSpec, OutputSpec},
+        task::{DataType, InputSpec, OutputSpec, TaskContext, TaskHandler, TaskResult},
         trigger::{TriggerDefinition, TriggerResult, TriggerSchema},
+        workflow::{DependencyRef, execution::WorkflowExecutor},
     };
 
+    struct ResizeImageHandler;
+
+    impl TaskHandler for ResizeImageHandler {
+        fn execute<'a>(&self, _inputs: &TaskContext<'a>) -> TaskResult<'a> {
+            let outputs = [("resized_file", Value::String("resized_image.jpg"))];
+            TaskResult::builder().outputs(outputs).build().unwrap()
+        }
+    }
+
+    struct CompressImageHandler;
+
+    impl TaskHandler for CompressImageHandler {
+        fn execute<'a>(&self, _inputs: &TaskContext<'a>) -> TaskResult<'a> {
+            let outputs = [("compressed_file", Value::String("compressed_image.jpg"))];
+            TaskResult::builder().outputs(outputs).build().unwrap()
+        }
+    }
+
+    struct UploadFileHandler;
+
+    impl TaskHandler for UploadFileHandler {
+        fn execute<'a>(&self, _inputs: &TaskContext<'a>) -> TaskResult<'a> {
+            TaskResult::default()
+        }
+    }
+
+    struct GenerateThumbnailHandler;
+
+    impl TaskHandler for GenerateThumbnailHandler {
+        fn execute<'a>(&self, _inputs: &TaskContext<'a>) -> TaskResult<'a> {
+            let outputs = [("thumbnail_file", Value::String("thumbnail_image.jpg"))];
+            TaskResult::builder().outputs(outputs).build().unwrap()
+        }
+    }
+
     #[test]
     fn test_all() {
         use uuid::Uuid;
 
         use crate::{
             Value,
-            task::{InputBinding, Task, TaskDefinition, TaskResult, TaskSchema},
+            task::{InputBinding, Task, TaskDefinition, TaskSchema},
             trigger::Trigger,
             workflow::Workflow,
         };
 
         let file_added_trigger = TriggerDefinition::builder()
             .name("file_added")
-            .triggered(|_ctx| TriggerResult::default())
             .schema(
                 TriggerSchema::builder()
                     .output(("file_path", DataType::File))
@@ -51,7 +89,7 @@ pub mod test {
                     .build()
                     .unwrap(),
             )
-            .execute(|_ctx| TaskResult::default())
+            .handler(Box::new(ResizeImageHandler))
             .build()
             .unwrap();
 
@@ -64,7 +102,7 @@ pub mod test {
                     .build()
                     .unwrap(),
             )
-            .execute(|_ctx| TaskResult::default())
+            .handler(Box::new(CompressImageHandler))
             .build()
             .unwrap();
 
@@ -77,7 +115,7 @@ pub mod test {
                     .build()
                     .unwrap(),
             )
-            .execute(|_ctx| TaskResult::default())
+            .handler(Box::new(UploadFileHandler))
             .build()
             .unwrap();
 
@@ -89,7 +127,7 @@ pub mod test {
                     .build()
                     .unwrap(),
             )
-            .execute(|_ctx| TaskResult::default())
+            .handler(Box::new(GenerateThumbnailHandler))
             .build()
             .unwrap();
 
@@ -144,7 +182,7 @@ pub mod test {
             ))
             .input(("width", InputBinding::literal(Value::Integer(1920))))
             .input(("height", InputBinding::literal(Value::Integer(1080))))
-            .dependency(new_file_trigger.id())
+            .dependency(DependencyRef::from_trigger(&new_file_trigger))
             .build()
             .unwrap();
 
@@ -190,10 +228,24 @@ pub mod test {
             .build()
             .unwrap();
 
+        let new_file_trigger_id = new_file_trigger.id();
+
         wf.add_trigger(new_file_trigger);
         wf.add_task(resize).unwrap();
         wf.add_task(compress).unwrap();
         wf.add_task(upload).unwrap();
         wf.add_task(thumbnail).unwrap();
+
+        let mut executor = WorkflowExecutor::builder()
+            .workflow(&wf)
+            .plugins(&registry)
+            .build()
+            .unwrap();
+        let mut outputs = HashMap::new();
+        outputs.insert("file_path", Value::String("/Downloads/image1.jpg"));
+        let result = TriggerResult::builder().outputs(outputs).build().unwrap();
+        executor
+            .execute_from_trigger(new_file_trigger_id, result)
+            .unwrap();
     }
 }
diff --git a/core/src/plugin/plugin.rs b/core/src/plugin/plugin.rs
index 08b37bb..fd742d3 100644
--- a/core/src/plugin/plugin.rs
+++ b/core/src/plugin/plugin.rs
@@ -5,21 +5,26 @@ use uuid::Uuid;
 use crate::{task::TaskDefinition, trigger::TriggerDefinition};
 use std::collections::HashMap;
 
-/// A Plugin encapsulates a set of tasks and triggers
-#[derive(Debug, Getters, Setters, Builder)]
+/// A Plugin encapsulates a set of tasks and triggers that can be registered and used within
+/// the workflow system.
+#[derive(Getters, Setters, Builder)]
 #[builder(pattern = "owned")]
 pub struct Plugin<'a> {
+    /// Unique identifier for the plugin
     #[getset(get = "pub")]
     #[builder(default = "Uuid::new_v4()")]
     id: Uuid,
 
+    /// Name of the plugin
     #[getset(get = "pub", set = "pub")]
     name: &'a str,
 
+    /// Tasks provided by the plugin
     #[getset(get = "pub")]
     #[builder(default)]
     tasks: HashMap<&'a str, TaskDefinition<'a>>,
 
+    /// Triggers provided by the plugin
     #[getset(get = "pub")]
     #[builder(default)]
     triggers: HashMap<&'a str, TriggerDefinition<'a>>,
diff --git a/core/src/plugin/registry.rs b/core/src/plugin/registry.rs
index 72b2dc5..2c4e8d9 100644
--- a/core/src/plugin/registry.rs
+++ b/core/src/plugin/registry.rs
@@ -4,6 +4,7 @@ use getset::Getters;
 use crate::plugin::Plugin;
 use std::collections::HashMap;
 
+/// Registry maintains a collection of registered plugins
 #[derive(Default, Getters, new)]
 pub struct Registry<'a> {
     #[get = "pub"]
@@ -12,18 +13,22 @@ pub struct Registry<'a> {
 }
 
 impl<'a> Registry<'a> {
+    /// Register a new plugin
     pub fn register_plugin(&mut self, plugin: Plugin<'a>) {
         self.plugins.insert(plugin.name().to_string(), plugin);
     }
 
+    /// Get a plugin by name
     pub fn get_plugin(&self, name: &str) -> Option<&Plugin<'a>> {
         self.plugins.get(name)
     }
 
+    /// Remove a plugin by name
     pub fn remove_plugin(&mut self, name: &str) -> Option<Plugin<'a>> {
         self.plugins.remove(name)
     }
 
+    /// List all registered plugin names
     pub fn list_plugins(&self) -> Vec<&str> {
         self.plugins.keys().map(|k| k.as_str()).collect()
     }
diff --git a/core/src/task/context.rs b/core/src/task/context.rs
index c3e71fe..c08e427 100644
--- a/core/src/task/context.rs
+++ b/core/src/task/context.rs
@@ -6,7 +6,7 @@ use uuid::Uuid;
 
 use crate::{
     logger::{Logger, ProgressReporter},
-    task::{TaskStatus, Value},
+    task::{TaskDefinition, TaskStatus, Value},
 };
 
 /// Contextual information available during task execution
@@ -20,6 +20,10 @@ pub struct TaskContext<'a> {
     #[getset(get = "pub")]
     task_name: &'a str,
 
+    /// Definition of the task
+    #[getset(get = "pub")]
+    task_definition: &'a TaskDefinition<'a>,
+
     /// Identifier of the workflow this task belongs to
     #[getset(get_copy = "pub")]
     workflow_id: Uuid,
@@ -54,11 +58,18 @@ pub struct TaskContext<'a> {
 
     /// Logging & progress
     #[getset(get = "pub")]
-    logger: &'a dyn Logger,
-    #[getset(get = "pub")]
-    progress: &'a dyn ProgressReporter,
+    #[builder(default)]
+    logger: Option<&'a dyn Logger>,
 
-    /// Workflow-level parameters
+    /// Progress reporter for the task execution
     #[getset(get = "pub")]
-    workflow_params: &'a HashMap<String, Value<'a>>,
+    #[builder(default)]
+    progress: Option<&'a dyn ProgressReporter>,
+}
+
+impl<'a> TaskContext<'a> {
+    /// Creates a new builder for TaskContext
+    pub fn builder() -> TaskContextBuilder<'a> {
+        TaskContextBuilder::default()
+    }
 }
diff --git a/core/src/task/datatype.rs b/core/src/task/datatype.rs
index 6032368..c2287c5 100644
--- a/core/src/task/datatype.rs
+++ b/core/src/task/datatype.rs
@@ -9,6 +9,7 @@ pub enum DataType {
     Boolean,
     Json,
     File,
+    Null,
 }
 
 impl std::fmt::Display for DataType {
@@ -20,6 +21,7 @@ impl std::fmt::Display for DataType {
             DataType::Boolean => "boolean",
             DataType::Json => "json",
             DataType::File => "file",
+            DataType::Null => "null",
         };
         write!(f, "{}", type_str)
     }
diff --git a/core/src/task/definition.rs b/core/src/task/definition.rs
index 7ef9745..7fbcb20 100644
--- a/core/src/task/definition.rs
+++ b/core/src/task/definition.rs
@@ -1,11 +1,11 @@
 use derive_builder::Builder;
 use getset::{Getters, Setters};
 
-use crate::task::{TaskContext, TaskResult, TaskSchema};
+use crate::task::{TaskContext, TaskHandler, TaskResult, TaskSchema};
 
 /// Definition of a kind of  Task within the workflow system.
 /// This is independent of any specific instance of a Task.
-#[derive(Builder, Getters, Setters, Debug)]
+#[derive(Builder, Getters, Setters)]
 #[builder(pattern = "owned")]
 pub struct TaskDefinition<'a> {
     /// Name of the task
@@ -19,7 +19,7 @@ pub struct TaskDefinition<'a> {
 
     /// Function that is called to execute the task
     #[getset(get = "pub")]
-    execute: fn(&TaskContext) -> TaskResult<'a>,
+    handler: Box<dyn TaskHandler>,
 }
 
 impl<'a> TaskDefinition<'a> {
@@ -27,4 +27,9 @@ impl<'a> TaskDefinition<'a> {
     pub fn builder() -> TaskDefinitionBuilder<'a> {
         TaskDefinitionBuilder::default()
     }
+
+    /// Execute the task with the given context
+    pub fn execute(&self, ctx: &TaskContext<'a>) -> TaskResult<'a> {
+        self.handler.execute(ctx)
+    }
 }
diff --git a/core/src/task/error.rs b/core/src/task/error.rs
index 2598c51..b321f4b 100644
--- a/core/src/task/error.rs
+++ b/core/src/task/error.rs
@@ -1,5 +1,6 @@
 use thiserror::Error;
 
+/// Errors that can occur during task definition or execution
 #[derive(Debug, Error)]
 pub enum TaskError {
     #[error("input '{input}' has incompatible type. expected '{expected}' but found '{found}'")]
diff --git a/core/src/task/mod.rs b/core/src/task/mod.rs
index 64a6eea..25e62f5 100644
--- a/core/src/task/mod.rs
+++ b/core/src/task/mod.rs
@@ -2,6 +2,7 @@ mod context;
 mod datatype;
 mod definition;
 mod error;
+mod handler;
 mod result;
 mod schema;
 mod status;
@@ -11,6 +12,7 @@ pub use context::TaskContext;
 pub use datatype::DataType;
 pub use definition::TaskDefinition;
 pub use error::{Result, TaskError};
+pub use handler::{NoOpTaskHandler, TaskHandler};
 pub use result::TaskResult;
 pub use schema::{InputSpec, OutputSpec, TaskSchema};
 pub use status::TaskStatus;
@@ -18,7 +20,7 @@ pub use task::Task;
 
 use uuid::Uuid;
 
-use crate::Value;
+use crate::{Value, workflow::DependencyRef};
 
 /// Represents how a task input is bound to a value or another task's output
 /// It can be a literal value, a reference to another task's output, or a reference to a trigger's output.
@@ -27,23 +29,30 @@ pub enum InputBinding<'a> {
     /// A literal value
     Literal(Value<'a>),
 
-    /// Reference to another task's output
-    TaskReference { task_id: Uuid, output: &'a str },
-
-    /// Reference to a trigger's output
-    TriggerReference { trigger_id: Uuid, output: &'a str },
+    Reference {
+        /// ID of the referenced entity (task or trigger)
+        ref_from: DependencyRef,
+        /// Output key from the referenced entity
+        output: &'a str,
+    },
 }
 
 /// Convenience constructors for InputBinding enum variants
 impl<'a> InputBinding<'a> {
     /// Creates a TriggerReference variant
     pub fn trigger(trigger_id: Uuid, output: &'a str) -> Self {
-        InputBinding::TriggerReference { trigger_id, output }
+        InputBinding::Reference {
+            ref_from: DependencyRef::Trigger(trigger_id),
+            output,
+        }
     }
 
     /// Creates a TaskReference variant
     pub fn task(task_id: Uuid, output: &'a str) -> Self {
-        InputBinding::TaskReference { task_id, output }
+        InputBinding::Reference {
+            ref_from: DependencyRef::Task(task_id),
+            output,
+        }
     }
 
     /// Creates a Literal variant
@@ -71,7 +80,7 @@ mod tests {
         let def = TaskDefinition::builder()
             .name("test")
             .schema(schema)
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
 
@@ -83,11 +92,7 @@ mod tests {
             .input(("foo", InputBinding::literal(Value::String("not an int"))))
             .build();
 
-        assert!(
-            result.is_err(),
-            "Expected error for type mismatch, got: {:?}",
-            result
-        );
+        assert!(result.is_err(), "Expected error for type mismatch",);
         let err = result.unwrap_err();
         assert!(
             err.to_string().contains("incompatible type"),
diff --git a/core/src/task/result.rs b/core/src/task/result.rs
index 083f940..1c1de31 100644
--- a/core/src/task/result.rs
+++ b/core/src/task/result.rs
@@ -6,7 +6,7 @@ use getset::{Getters, Setters};
 use crate::task::{TaskStatus, Value};
 
 /// Represents the result of a task execution including status, outputs, logs, and metrics
-#[derive(Builder, Getters, Setters)]
+#[derive(Builder, Getters, Setters, Clone, Debug)]
 #[builder(pattern = "owned", setter(into))]
 pub struct TaskResult<'a> {
     /// Status of the task execution
diff --git a/core/src/task/status.rs b/core/src/task/status.rs
index e087444..5c67c1e 100644
--- a/core/src/task/status.rs
+++ b/core/src/task/status.rs
@@ -11,7 +11,7 @@ pub enum TaskStatus {
     Completed,
 
     /// Task execution has failed
-    Failed(&'static str),
+    Failed,
 }
 
 impl Default for TaskStatus {
diff --git a/core/src/task/task.rs b/core/src/task/task.rs
index fa7ba2c..01558dc 100644
--- a/core/src/task/task.rs
+++ b/core/src/task/task.rs
@@ -1,13 +1,16 @@
-use std::collections::HashMap;
+use std::collections::{HashMap, HashSet};
 
 use derive_builder::Builder;
 use getset::{CopyGetters, Getters, Setters};
 use uuid::Uuid;
 
-use crate::task::{InputBinding, TaskDefinition, TaskError, TaskStatus};
+use crate::{
+    task::{InputBinding, TaskDefinition, TaskError, TaskStatus},
+    workflow::DependencyRef,
+};
 
 /// Represents an instance of a Task within a workflow
-#[derive(Getters, Setters, CopyGetters, Builder, Debug, Clone)]
+#[derive(Getters, Setters, CopyGetters, Builder, Clone)]
 #[builder(pattern = "owned", setter(into), build_fn(validate = "Self::validate"))]
 pub struct Task<'a> {
     /// Unique identifier for the task
@@ -38,7 +41,7 @@ pub struct Task<'a> {
     /// execution order.
     #[getset(get = "pub", get_mut = "pub")]
     #[builder(default, setter(each = "dependency"))]
-    dependencies: Vec<Uuid>,
+    dependencies: HashSet<DependencyRef>,
 
     /// Current status of the task
     #[getset(get = "pub")]
@@ -63,13 +66,13 @@ impl<'a> Task<'a> {
     }
 
     /// Adds a dependency on another task by its UUID
-    pub fn add_dependency(&mut self, task_id: Uuid) {
-        self.dependencies.push(task_id);
+    pub fn add_dependency(&mut self, dependency: DependencyRef) {
+        self.dependencies.insert(dependency);
     }
 
     /// Removes a dependency on another task by its UUID
-    pub fn remove_dependency(&mut self, task_id: Uuid) {
-        self.dependencies.retain(|&id| id != task_id);
+    pub fn remove_dependency(&mut self, dependency: DependencyRef) {
+        self.dependencies.remove(&dependency);
     }
 
     /// Clears all dependencies
@@ -95,6 +98,47 @@ impl<'a> Task<'a> {
     pub fn remove_input(&mut self, key: &str) {
         self.inputs.remove(key);
     }
+
+    /// Retrieves all dependencies of the task, including dependencies via input bindings, as well
+    /// as explicit dependencies. Returns a tuple: (task dependencies, trigger dependencies).
+    pub fn get_all_dependencies(&self) -> Vec<DependencyRef> {
+        let mut deps = Vec::new();
+        // Collect from input bindings
+        for binding in self.inputs.values() {
+            if let InputBinding::Reference { ref_from, .. } = binding {
+                if !deps.contains(ref_from) {
+                    deps.push(ref_from.clone());
+                }
+            }
+        }
+        // Collect explicit dependencies
+        for dep in &self.dependencies {
+            if !deps.contains(dep) {
+                deps.push(dep.clone());
+            }
+        }
+        deps
+    }
+}
+
+impl<'a> PartialEq for Task<'a> {
+    fn eq(&self, other: &Self) -> bool {
+        self.id == other.id
+    }
+}
+
+impl<'a> Eq for Task<'a> {}
+
+use std::fmt;
+
+impl<'a> fmt::Debug for Task<'a> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("Task")
+            .field("id", &self.id)
+            .field("name", &self.name)
+            // Add other fields as appropriate
+            .finish()
+    }
 }
 
 impl<'a> TaskBuilder<'a> {
diff --git a/core/src/trigger/context.rs b/core/src/trigger/context.rs
index b37c5f4..d527d5d 100644
--- a/core/src/trigger/context.rs
+++ b/core/src/trigger/context.rs
@@ -9,3 +9,10 @@ pub struct TriggerContext<'a> {
     #[getset(get_copy = "pub")]
     trigger_name: &'a str,
 }
+
+impl<'a> TriggerContext<'a> {
+    /// Creates a new builder for TriggerContext
+    pub fn builder() -> TriggerContextBuilder<'a> {
+        TriggerContextBuilder::default()
+    }
+}
diff --git a/core/src/trigger/definition.rs b/core/src/trigger/definition.rs
index f56552f..55b8ae3 100644
--- a/core/src/trigger/definition.rs
+++ b/core/src/trigger/definition.rs
@@ -1,7 +1,7 @@
 use derive_builder::Builder;
 use getset::{Getters, Setters};
 
-use crate::trigger::{TriggerContext, TriggerResult, TriggerSchema};
+use crate::trigger::TriggerSchema;
 
 /// Definition of a kind of Trigger within the workflow system.
 /// This is independent of any specific instance of a Trigger.
@@ -18,10 +18,6 @@ pub struct TriggerDefinition<'a> {
     #[builder(default)]
     #[getset(get = "pub")]
     schema: TriggerSchema<'a>,
-
-    /// Function called when the trigger is evaluated
-    #[getset(get = "pub")]
-    triggered: fn(&TriggerContext<'a>) -> TriggerResult,
 }
 
 impl<'a> TriggerDefinition<'a> {
diff --git a/core/src/trigger/result.rs b/core/src/trigger/result.rs
index 1e1b960..2e0bdd5 100644
--- a/core/src/trigger/result.rs
+++ b/core/src/trigger/result.rs
@@ -1,7 +1,23 @@
+use std::collections::HashMap;
+
 use derive_builder::Builder;
 use getset::{Getters, Setters};
 
+use crate::Value;
+
 /// Represents the result of evaluating a trigger in the workflow
-#[derive(Builder, Getters, Setters, Default)]
+#[derive(Builder, Getters, Setters, Default, Clone)]
 #[builder(pattern = "owned", setter(into))]
-pub struct TriggerResult {}
+pub struct TriggerResult<'a> {
+    /// outputs produced by the trigger
+    #[getset(get = "pub")]
+    #[builder(default, setter(each = "output"))]
+    pub outputs: HashMap<&'a str, Value<'a>>,
+}
+
+impl<'a> TriggerResult<'a> {
+    /// Creates a new builder for TriggerResult
+    pub fn builder() -> TriggerResultBuilder<'a> {
+        TriggerResultBuilder::default()
+    }
+}
diff --git a/core/src/value.rs b/core/src/value.rs
index 0124aeb..d8ea4fa 100644
--- a/core/src/value.rs
+++ b/core/src/value.rs
@@ -11,6 +11,7 @@ pub enum Value<'a> {
     Boolean(bool),
     Json(serde_json::Value),
     FilePath(PathBuf),
+    Null,
 }
 
 impl<'a> Value<'a> {
@@ -23,6 +24,7 @@ impl<'a> Value<'a> {
             Value::Boolean(_) => DataType::Boolean,
             Value::Json(_) => DataType::Json,
             Value::FilePath(_) => DataType::File,
+            Value::Null => DataType::Null,
         }
     }
 }
diff --git a/core/src/workflow/error.rs b/core/src/workflow/error.rs
index bdf62ad..d92546c 100644
--- a/core/src/workflow/error.rs
+++ b/core/src/workflow/error.rs
@@ -2,8 +2,12 @@
 use thiserror::Error;
 use uuid::Uuid;
 
-use crate::{task::DataType, workflow::ReferenceKind};
+use crate::{
+    task::DataType,
+    workflow::{DependencyRef, execution::ExecutionError},
+};
 
+/// Errors related to workflows that can occur during workflow definition, validation, or execution
 #[derive(Debug, Error)]
 pub enum WorkflowError {
     #[error("task {id} already exists in workflow")]
@@ -49,17 +53,19 @@ pub enum WorkflowError {
     InputNotInSchema { task_id: Uuid, input: String },
 
     #[error(
-        "type mismatch for input '{input}' in task '{task_id}': expected {expected}, but referenced output '{output}' from {reference_kind} ID {reference_id} is {found}"
+        "type mismatch for input '{input}' in task '{task_id}': expected {expected}, but referenced output '{output}' from {reference} is {found}"
     )]
     InputTypeMismatch {
         task_id: Uuid,
         input: String,
         expected: DataType,
         found: DataType,
-        reference_id: Uuid,
-        reference_kind: ReferenceKind,
+        reference: DependencyRef,
         output: String,
     },
+
+    #[error("execution error: {0}")]
+    Execution(#[from] ExecutionError),
 }
 
 pub type Result<T> = std::result::Result<T, WorkflowError>;
diff --git a/core/src/workflow/mod.rs b/core/src/workflow/mod.rs
index c3c633b..341fb78 100644
--- a/core/src/workflow/mod.rs
+++ b/core/src/workflow/mod.rs
@@ -1,5 +1,8 @@
+mod context;
 mod error;
+pub mod execution;
 
+pub use context::WorkflowExecutionContext;
 pub use error::{Result, WorkflowError};
 
 use crate::{
@@ -9,29 +12,45 @@ use crate::{
 
 use derive_builder::Builder;
 use getset::{Getters, Setters};
-use std::collections::HashMap;
+use std::{
+    collections::{HashMap, HashSet},
+    fmt::Display,
+};
 use uuid::Uuid;
 
-/// Enum to distinguish between Task and Trigger references
-#[derive(Debug)]
-pub enum ReferenceKind {
-    Task,
-    Trigger,
+/// Reference to either a Task or a Trigger within the Workflow
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+pub enum DependencyRef {
+    Task(Uuid),
+    Trigger(Uuid),
 }
 
-impl std::fmt::Display for ReferenceKind {
-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-        let s = match self {
-            ReferenceKind::Task => "task",
-            ReferenceKind::Trigger => "trigger",
-        };
-        write!(f, "{}", s)
+impl DependencyRef {
+    /// Get the UUID of the referenced entity
+    pub fn id(&self) -> Uuid {
+        match self {
+            DependencyRef::Task(id) => *id,
+            DependencyRef::Trigger(id) => *id,
+        }
+    }
+
+    /// Create a DependencyRef from a Task
+    pub fn from_task(task: &Task) -> Self {
+        DependencyRef::Task(task.id())
+    }
+
+    /// Create a DependencyRef from a Trigger
+    pub fn from_trigger(trigger: &Trigger) -> Self {
+        DependencyRef::Trigger(trigger.id())
     }
 }
 
-impl From<ReferenceKind> for String {
-    fn from(kind: ReferenceKind) -> Self {
-        kind.to_string()
+impl Display for DependencyRef {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        match self {
+            DependencyRef::Task(id) => write!(f, "Task({})", id),
+            DependencyRef::Trigger(id) => write!(f, "Trigger({})", id),
+        }
     }
 }
 
@@ -54,12 +73,12 @@ pub struct Workflow<'a> {
 
     /// Tasks within the workflow
     #[getset(get = "pub")]
-    #[builder(default)]
+    #[builder(default, setter(each = "task"))]
     tasks: HashMap<Uuid, Task<'a>>,
 
     /// Triggers within the workflow
     #[getset(get = "pub")]
-    #[builder(default)]
+    #[builder(default, setter(each = "trigger"))]
     triggers: HashMap<Uuid, Trigger<'a>>,
 }
 
@@ -81,26 +100,8 @@ impl<'a> Workflow<'a> {
     /// Validate that all input types for a task match the types of the referenced outputs
     fn validate_task_input_types(&self, task: &Task<'a>) -> Result<()> {
         for (input_key, binding) in task.inputs() {
-            match binding {
-                InputBinding::TaskReference { task_id, output } => {
-                    self.validate_reference(
-                        task,
-                        input_key,
-                        *task_id,
-                        output,
-                        ReferenceKind::Task,
-                    )?;
-                }
-                InputBinding::TriggerReference { trigger_id, output } => {
-                    self.validate_reference(
-                        task,
-                        input_key,
-                        *trigger_id,
-                        output,
-                        ReferenceKind::Trigger,
-                    )?;
-                }
-                _ => {}
+            if let InputBinding::Reference { ref_from, output } = binding {
+                self.validate_reference(task, input_key, *ref_from, output)?;
             }
         }
         Ok(())
@@ -111,9 +112,8 @@ impl<'a> Workflow<'a> {
         &self,
         task: &Task<'a>,
         input_key: &str,
-        ref_from: Uuid,
+        ref_from: DependencyRef,
         output_key: &str,
-        kind: ReferenceKind,
     ) -> Result<()> {
         // Get the input spec from the task's schema
         let input_spec = task
@@ -127,14 +127,15 @@ impl<'a> Workflow<'a> {
             })?;
 
         // Get the referenced output spec
-        let output_type: &DataType = match kind {
-            ReferenceKind::Task => {
-                let referenced_task = self.tasks.get(&ref_from).ok_or_else(|| {
-                    WorkflowError::MissingTaskDependency {
-                        input: input_key.to_string(),
-                        id: ref_from,
-                    }
-                })?;
+        let output_type: &DataType = match ref_from {
+            DependencyRef::Task(id) => {
+                let referenced_task =
+                    self.tasks
+                        .get(&id)
+                        .ok_or_else(|| WorkflowError::MissingTaskDependency {
+                            input: input_key.to_string(),
+                            id,
+                        })?;
                 referenced_task
                     .definition()
                     .schema()
@@ -143,15 +144,15 @@ impl<'a> Workflow<'a> {
                     .ok_or_else(|| WorkflowError::MissingTaskOutput {
                         input: input_key.to_string(),
                         output: output_key.to_string(),
-                        id: ref_from,
+                        id,
                     })?
                     .data_type()
             }
-            ReferenceKind::Trigger => {
-                let referenced_trigger = self.triggers.get(&ref_from).ok_or_else(|| {
+            DependencyRef::Trigger(id) => {
+                let referenced_trigger = self.triggers.get(&id).ok_or_else(|| {
                     WorkflowError::MissingTriggerDependency {
                         input: input_key.to_string(),
-                        id: ref_from,
+                        id,
                     }
                 })?;
                 referenced_trigger
@@ -162,7 +163,7 @@ impl<'a> Workflow<'a> {
                     .ok_or_else(|| WorkflowError::MissingTriggerOutput {
                         input: input_key.to_string(),
                         output: output_key.to_string(),
-                        id: ref_from,
+                        id,
                     })?
             }
         };
@@ -174,8 +175,7 @@ impl<'a> Workflow<'a> {
                 input: input_key.to_string(),
                 expected: input_spec.data_type().clone(),
                 found: output_type.clone(),
-                reference_id: ref_from,
-                reference_kind: kind,
+                reference: ref_from,
                 output: output_key.to_string(),
             });
         }
@@ -189,67 +189,67 @@ impl<'a> Workflow<'a> {
     }
 
     /// Generalized method to find all tasks that depend on a given predicate over InputBinding
-    fn find_tasks_with_input_binding<F>(&self, mut pred: F) -> Vec<Uuid>
+    #[allow(dead_code)]
+    fn find_tasks_with_input_binding<F>(&self, mut pred: F) -> Vec<DependencyRef>
     where
-        F: FnMut(&InputBinding<'a>) -> bool,
+        F: FnMut(&InputBinding<'a>) -> Option<DependencyRef>,
     {
-        self.tasks
-            .iter()
-            .filter_map(|(&id, t)| {
-                if t.inputs().values().any(|b| pred(b)) {
-                    Some(id)
-                } else {
-                    None
+        let mut refs = Vec::new();
+        for (&_, t) in &self.tasks {
+            for b in t.inputs().values() {
+                if let Some(dep_ref) = pred(b) {
+                    refs.push(dep_ref);
                 }
-            })
-            .collect()
-    }
-
-    /// Find all tasks that depend on a given task ID (directly or via inputs)
-    fn find_tasks_depending_on_task(&self, task_id: Uuid) -> Vec<Uuid> {
-        let mut ids = self.find_tasks_with_input_binding(
-            |b| matches!(b, InputBinding::TaskReference { task_id: tid, .. } if *tid == task_id),
-        );
-        // Also include tasks that have this task_id in their depends_on
-        ids.extend(self.tasks.iter().filter_map(|(&id, t)| {
-            if t.dependencies().contains(&task_id) {
-                Some(id)
-            } else {
-                None
             }
-        }));
-        ids.sort();
-        ids.dedup();
-        ids
+        }
+        refs
     }
 
-    /// Find all tasks that depend on a given trigger ID (via inputs)
-    fn find_tasks_depending_on_trigger(&self, trigger_id: Uuid) -> Vec<Uuid> {
-        self.find_tasks_with_input_binding(|b| {
-            matches!(b, InputBinding::TriggerReference { trigger_id: tid, .. } if *tid == trigger_id)
-        })
+    /// Find all tasks that depend on a given DependencyRef (directly or via inputs)
+    fn find_tasks_depending_on(&self, dep_ref: &DependencyRef) -> HashSet<DependencyRef> {
+        self.tasks
+            .values()
+            .filter(|t| {
+                let input_ref_found = t.inputs().values().any(|b| {
+                matches!(b, InputBinding::Reference { ref_from, .. } if ref_from == dep_ref)
+            });
+                let depends_on_found = t.dependencies().contains(dep_ref);
+                input_ref_found || depends_on_found
+            })
+            .map(|t| DependencyRef::Task(t.id()))
+            .collect()
     }
 
     /// Helper to detach references from dependents for both tasks and triggers
-    fn detach_references<F>(&mut self, dependents: Vec<Uuid>, mut should_remove: F)
-    where
-        F: FnMut(&InputBinding<'a>, Uuid) -> bool,
-    {
+    fn detach_references(&mut self, dependents: Vec<Uuid>, dep_ref: &DependencyRef) {
         for dep_id in dependents {
             if let Some(dep_task) = self.tasks.get_mut(&dep_id) {
                 // Remove from depends_on
-                dep_task.remove_dependency(dep_id);
+                match dep_ref {
+                    DependencyRef::Task(_) => dep_task.remove_dependency(*dep_ref),
+                    DependencyRef::Trigger(_) => dep_task.remove_dependency(*dep_ref),
+                }
 
                 // Collect keys to remove first
                 let keys_to_remove: Vec<_> = dep_task
                     .inputs()
                     .iter()
-                    .filter_map(|(&key, binding)| {
-                        if should_remove(binding, dep_id) {
-                            Some(key)
-                        } else {
-                            None
-                        }
+                    .filter_map(|(&key, binding)| match (dep_ref, binding) {
+                        (
+                            DependencyRef::Task(task_id),
+                            InputBinding::Reference {
+                                ref_from: DependencyRef::Task(tid),
+                                ..
+                            },
+                        ) if tid == task_id => Some(key),
+                        (
+                            DependencyRef::Trigger(trigger_id),
+                            InputBinding::Reference {
+                                ref_from: DependencyRef::Trigger(tid),
+                                ..
+                            },
+                        ) if tid == trigger_id => Some(key),
+                        _ => None,
                     })
                     .collect();
 
@@ -261,8 +261,22 @@ impl<'a> Workflow<'a> {
         }
     }
 
+    /// Removes a task from the workflow, handling dependents based on the specified DeleteMode.
+    /// There are three modes:
+    /// - Strict: Returns an error if dependents exist.
+    /// - Cascade: Removes dependents recursively.
+    /// - Detach: Keeps dependents but removes references to the deleted task.
+    /// # Errors
+    /// - `WorkflowError::TaskHasDependents` if in Strict mode and dependents exist.
+    /// - Errors from removing dependent tasks in Cascade mode.
+    /// - Errors from detaching references in Detach mode.  
     pub fn remove_task(&mut self, task_id: Uuid, mode: DeleteMode) -> Result<()> {
-        let dependents = self.find_tasks_depending_on_task(task_id);
+        let dep_ref = DependencyRef::Task(task_id);
+        let dependents: Vec<Uuid> = self
+            .find_tasks_depending_on(&dep_ref)
+            .iter()
+            .map(|t| t.id())
+            .collect();
 
         match mode {
             DeleteMode::Strict => {
@@ -275,14 +289,12 @@ impl<'a> Workflow<'a> {
                 }
             }
             DeleteMode::Cascade => {
-                for dep_id in dependents {
-                    self.remove_task(dep_id, DeleteMode::Cascade)?;
+                for dep_id in &dependents {
+                    self.remove_task(*dep_id, DeleteMode::Cascade)?;
                 }
             }
             DeleteMode::Detach => {
-                self.detach_references(dependents, |binding, _id| {
-                    matches!(binding, InputBinding::TaskReference { task_id: tid, .. } if *tid == task_id)
-                });
+                self.detach_references(dependents, &dep_ref);
             }
         }
 
@@ -290,8 +302,22 @@ impl<'a> Workflow<'a> {
         Ok(())
     }
 
+    /// Removes a trigger from the workflow, handling dependents based on the specified DeleteMode.
+    /// There are three modes:
+    /// - Strict: Returns an error if dependents exist.
+    /// - Cascade: Removes dependents recursively.
+    /// - Detach: Keeps dependents but removes references to the deleted trigger.
+    /// # Errors
+    /// - `WorkflowError::TriggerHasDependents` if in Strict mode and dependents exist.
+    /// - Errors from removing dependent tasks in Cascade mode.
+    /// - Errors from detaching references in Detach mode.
     pub fn remove_trigger(&mut self, trigger_id: Uuid, mode: DeleteMode) -> Result<()> {
-        let dependents = self.find_tasks_depending_on_trigger(trigger_id);
+        let dep_ref = DependencyRef::Trigger(trigger_id);
+        let dependents: Vec<Uuid> = self
+            .find_tasks_depending_on(&dep_ref)
+            .iter()
+            .map(|t| t.id())
+            .collect();
 
         match mode {
             DeleteMode::Strict => {
@@ -303,14 +329,12 @@ impl<'a> Workflow<'a> {
                 }
             }
             DeleteMode::Cascade => {
-                for dep_id in dependents {
-                    self.remove_task(dep_id, DeleteMode::Cascade)?;
+                for dep_id in &dependents {
+                    self.remove_task(*dep_id, DeleteMode::Cascade)?;
                 }
             }
             DeleteMode::Detach => {
-                self.detach_references(dependents, |binding, _id| {
-                    matches!(binding, InputBinding::TriggerReference { trigger_id: tid, .. } if *tid == trigger_id)
-                });
+                self.detach_references(dependents, &dep_ref);
             }
         }
 
@@ -318,16 +342,29 @@ impl<'a> Workflow<'a> {
         Ok(())
     }
 
+    /// Verifies that all dependencies of a task exist within the workflow
     fn verify_task_dependencies(&self, task: &Task<'a>) -> Result<()> {
-        for dep_id in task.dependencies() {
-            if !self.tasks.contains_key(dep_id) && !self.triggers.contains_key(dep_id) {
-                return Err(WorkflowError::MissingDependency { id: *dep_id });
+        for dep in task.dependencies() {
+            match dep {
+                DependencyRef::Task(dep_id) => {
+                    if !self.tasks.contains_key(dep_id) {
+                        return Err(WorkflowError::MissingDependency { id: *dep_id });
+                    }
+                }
+                DependencyRef::Trigger(dep_id) => {
+                    if !self.triggers.contains_key(dep_id) {
+                        return Err(WorkflowError::MissingDependency { id: *dep_id });
+                    }
+                }
             }
         }
 
         for (input, binding) in task.inputs() {
             match binding {
-                InputBinding::TaskReference { task_id, output } => {
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Task(task_id),
+                    output,
+                } => {
                     if !self.tasks.contains_key(task_id) {
                         Err(WorkflowError::MissingTaskDependency {
                             input: input.to_string(),
@@ -348,7 +385,10 @@ impl<'a> Workflow<'a> {
                         })?;
                     }
                 }
-                InputBinding::TriggerReference { trigger_id, output } => {
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Trigger(trigger_id),
+                    output,
+                } => {
                     if !self.triggers.contains_key(trigger_id) {
                         Err(WorkflowError::MissingTriggerDependency {
                             input: input.to_string(),
@@ -376,19 +416,27 @@ impl<'a> Workflow<'a> {
     }
 }
 
+/// Modes for deleting tasks or triggers from a workflow
+#[derive(Debug, Clone, Copy)]
 pub enum DeleteMode {
-    Strict,  // panic / return error if dependents exist
-    Cascade, // remove dependents recursively
-    Detach,  // keep dependents, just remove references to the deleted entity
+    /// Strict mode: Returns an error if dependents exist.
+    Strict,
+
+    /// Cascade mode: Removes dependents recursively.
+    Cascade,
+
+    /// Detach mode: Keeps dependents but removes references to the deleted entity.
+    Detach,
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
     use crate::task::{
-        DataType, InputBinding, InputSpec, OutputSpec, Task, TaskDefinition, TaskResult, TaskSchema,
+        DataType, InputBinding, InputSpec, NoOpTaskHandler, OutputSpec, Task, TaskDefinition,
+        TaskSchema,
     };
-    use crate::trigger::{Trigger, TriggerDefinition, TriggerResult, TriggerSchema};
+    use crate::trigger::{Trigger, TriggerDefinition, TriggerSchema};
     use uuid::Uuid;
 
     fn dummy_task_def<'a>() -> TaskDefinition<'a> {
@@ -400,7 +448,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap()
     }
@@ -414,7 +462,6 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .triggered(|_| TriggerResult::default())
             .build()
             .unwrap()
     }
@@ -431,7 +478,7 @@ mod tests {
             .unwrap();
         // Add a fake dependency
         let missing_id = Uuid::new_v4();
-        task.add_dependency(missing_id);
+        task.add_dependency(DependencyRef::Task(missing_id));
         let res = wf.add_task(task);
         assert!(res.is_err());
         if let Err(e) = res {
@@ -460,7 +507,7 @@ mod tests {
             .id(t2_id)
             .name("t2")
             .definition(&def)
-            .dependencies(vec![t1_id])
+            .dependencies([DependencyRef::Task(t1_id)])
             .build()
             .unwrap();
         wf.add_task(t1).unwrap();
@@ -486,7 +533,7 @@ mod tests {
             .id(t2_id)
             .name("t2")
             .definition(&def)
-            .dependencies(vec![t1_id])
+            .dependencies([DependencyRef::Task(t1_id)])
             .build()
             .unwrap();
         wf.add_task(t1).unwrap();
@@ -512,7 +559,7 @@ mod tests {
             .id(t2_id)
             .name("t2")
             .definition(&def)
-            .dependencies(vec![t1_id])
+            .dependencies([DependencyRef::Task(t1_id)])
             .build()
             .unwrap();
         wf.add_task(t1).unwrap();
@@ -543,8 +590,8 @@ mod tests {
             .definition(&def)
             .input((
                 "foo",
-                InputBinding::TriggerReference {
-                    trigger_id,
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Trigger(trigger_id),
                     output: "bar",
                 },
             ))
@@ -569,7 +616,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
         let t1_id = Uuid::new_v4();
@@ -590,7 +637,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
         let t2 = Task::builder()
@@ -599,8 +646,8 @@ mod tests {
             .definition(&def2)
             .input((
                 "foo",
-                InputBinding::TaskReference {
-                    task_id: t1_id,
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Task(t1_id),
                     output: "out",
                 },
             ))
@@ -617,8 +664,7 @@ mod tests {
                     input,
                     expected,
                     found,
-                    reference_id: _,
-                    reference_kind: _,
+                    reference: _,
                     output: _,
                 } => {
                     assert_eq!(input, "foo");
@@ -643,7 +689,6 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .triggered(|_| TriggerResult::default())
             .build()
             .unwrap();
         let trigger_id = Uuid::new_v4();
@@ -664,7 +709,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
         let t = Task::builder()
@@ -673,8 +718,8 @@ mod tests {
             .definition(&def)
             .input((
                 "foo",
-                InputBinding::TriggerReference {
-                    trigger_id,
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Trigger(trigger_id),
                     output: "bar",
                 },
             ))
@@ -691,8 +736,7 @@ mod tests {
                     input,
                     expected,
                     found,
-                    reference_id: _,
-                    reference_kind: _,
+                    reference: _,
                     output: _,
                 } => {
                     assert_eq!(input, "foo");
@@ -717,7 +761,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
         let t1_id = Uuid::new_v4();
@@ -738,7 +782,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
         let t2 = Task::builder()
@@ -747,8 +791,8 @@ mod tests {
             .definition(&def2)
             .input((
                 "foo",
-                InputBinding::TaskReference {
-                    task_id: t1_id,
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Task(t1_id),
                     output: "out",
                 },
             ))
@@ -772,7 +816,6 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .triggered(|_| TriggerResult::default())
             .build()
             .unwrap();
         let trigger_id = Uuid::new_v4();
@@ -793,7 +836,7 @@ mod tests {
                     .build()
                     .unwrap(),
             )
-            .execute(|_| TaskResult::default())
+            .handler(Box::new(NoOpTaskHandler))
             .build()
             .unwrap();
         let t = Task::builder()
@@ -802,8 +845,8 @@ mod tests {
             .definition(&def)
             .input((
                 "foo",
-                InputBinding::TriggerReference {
-                    trigger_id,
+                InputBinding::Reference {
+                    ref_from: DependencyRef::Trigger(trigger_id),
                     output: "bar",
                 },
             ))
